"use strict";
var fs = require("fs");
var parseArgs = require("minimist");
var os_1 = require("os");
var path = require("path");
var gitignore_1 = require("./gitignore");
var config_1 = require("./models/config");
var Cdp = (function () {
    function Cdp() {
        this.configsPath = "configs.json";
    }
    Cdp.prototype.main = function (args) {
        // parse argments
        var argv = parseArgs(args.slice(2), { boolean: true });
        // in process
        if (argv.in && argv._.length > 0) {
            // create configs.json if exists
            try {
                fs.statSync(this.configsPath);
            }
            catch (e) {
                fs.writeFileSync(this.configsPath, "[]", { encoding: "utf-8" });
            }
            // read config.json
            var configs_1 = JSON.parse(fs.readFileSync(this.configsPath, "utf-8"));
            argv._.forEach(function (arg) {
                var filePath = path.normalize(arg).split(path.sep).join("/");
                // read file
                var body = fs.readFileSync(filePath, "utf-8");
                var format = "plain";
                try {
                    // try parse JSON
                    body = JSON.parse(body);
                    format = "json";
                }
                catch (e) {
                    // split new line if plain
                    body = body.split(/\r?\n/);
                }
                // join configs.json
                var config = new config_1.Config(filePath, format, body);
                var find = configs_1.map(function (value, index) {
                    return { i: index, v: value };
                }).filter(function (m) { return m.v.path === config.path; });
                if (find.length > 0) {
                    // update config
                    configs_1[find[0].i] = config;
                }
                else {
                    // insert config
                    configs_1.push(config);
                }
            });
            // write configs.json
            fs.writeFileSync(this.configsPath, JSON.stringify(configs_1, null, 2), { encoding: "utf-8" });
            // gitignore option
            if (argv.gitignore) {
                new gitignore_1.GitIgnore().merge(argv._);
            }
            // after delete option
            if (argv.afterdelete) {
                argv._.forEach(function (filePath) { try {
                    fs.unlinkSync(filePath);
                }
                catch (e) {
                    console.log(filePath + " was already deleted.");
                } });
            }
        }
        else if (argv.out) {
            var configs = JSON.parse(fs.readFileSync(this.configsPath, "utf-8"));
            configs.forEach(function (config) {
                switch (config.format) {
                    case "plain":
                        fs.writeFileSync(config.path, config.body.join(os_1.EOL), { encoding: "utf-8" });
                        break;
                    case "json":
                        fs.writeFileSync(config.path, JSON.stringify(config.body, null, 2), { encoding: "utf-8" });
                        break;
                    default:
                        break;
                }
            });
        }
        else {
            // show cdp Help
            console.log("Usage: cdp mode\n");
            console.log("mode:");
            console.log("--in [--afterdelete] [--gitignore] [filePath] Checkin for configs.json.");
            console.log("  --afterdelete                               Delete files after checkin.");
            console.log("  --gitignore                                 Add files to gitignore.");
            console.log("--out                                         Checkout from configs.json.");
        }
    };
    return Cdp;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cdp;
//# sourceMappingURL=cdp.js.map